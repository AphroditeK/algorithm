### 二叉搜索树(binary search tree)
+ 主要应用于查找问题  
	* 二分查找法(适用于有序序列)   
	* 循环和递归两种实现方式，还有floor/ceil函数的作用  
	![floor/ceil函数](./../../source/binarysearch.png)  
+ 二叉搜索树是指一种二叉树的数据结构，它有以下一些特点    
	* 每个节点大于左儿子，小于右儿子  
	* 以左右节点作为根节点也是新的二分搜索树  
	* 区别于堆的完全二叉树结构，它不一定是一个完全二叉树  
	* 优点（方便回答很多数据之间的关系问题）  
		+ 根据key值可以快速查找数据，时间复杂度(O(logn))  
		+ 快速找到最值（max/min）  
		+ floor/ceil函数  
		+ rank    
	* 深度优先遍历  
		+ 前序遍历  
		+ 中序遍历（相当于排序）  
		+ 后序遍历（清空树操作）  
	* 广度优先遍历  
		+ 层序遍历 
	* 删除
		+ 删除最大值
		+ 删除最小值
		+ 删除对应key值
	* 元素顺序性
		+ 前驱（小于该元素key的最大结点）
		+ 后继（大于该元素key的最小结点）
		+ floor（小于或等于某key（该key值可能不存在于树中）的最大元素）：地板函数，类似于前驱
		+ ceil（大于或等于某key（该key值可能不存在于树中）的最小元素）：天花板函数，类似于后继
		+ rank（某个元素的排名），解决方案：每个节点再记录一个数据，记录的是以该节点为根的子树的结点个数，这样，找到要找的元素后，用于记录的数就发挥了作用。统计比它小的元素的个数+1就是它的排名rank
		+ select（选取给定排名的元素），也是通过上面rank的的做法得到
		+ 注意：(前驱/后继)和(floor/ceil)的区别在于前者元素必须存在，后者不一定，当元素存在时，他的ceil和floor就是它自己本身
	* 支持重复元素的二分搜索树
		+ 支持重复是指key值重复，两种解决方案
		+ 一是把相等的也放到左孩子
		+ 二是把结点的value变为一个数组，新加一个count属性作为该key的元素个数
	* 二分搜索树的局限性
		+ 相同数据可以对应不同的二分搜索树，原因是根节点的选取不同
		+ 根节点应尽可能选取到中间元素，因为二分搜索树的查找时间是与树的高相关的
		+ 根节点选取到最小元素时，根节点就出现没有左子树的情况
		+ 根节点选取到大元素时，根节点就出现没有右子树的情况
		+ 极端情况就是数据元素以近乎有序的方式流进二分搜索树中，退化成了链表
	* 平衡二叉树（解决上面二叉搜索树退化成链表的问题）
		+ 红黑树（最为著名常用）
		+ 2-3树
		+ AVL树
		+ Splay tree
	* 平衡二叉树和堆的结合：treap
	![二分搜索树](./../../source/binarySearchTree.png)
+ trie树，常用于字典匹配，并且统计词频
+ 树形问题
	* 递归法天然的树形性质（归并排序，快速排序等）
	* 搜索问题（很多问题其实都是可以通过搜索解决）
		+ 决策树（通过搜索当前情况，遍历所有的决策，并选出最优的决策的过程）
		+ 搬运工游戏等等
	* KD树
	* 区间树
	* 哈夫曼树
### 红黑树
+ 这里单独讲一下红黑树，因为TreeMap、TreeSet以及JDK1.8之后的HashMap底层都用到了红黑树
+ 在理解红黑树之前，先理解B树会对红黑树的各种性质有更好的理解
+ 红黑树是一种自平衡的二叉查找树，本质上是一棵平衡二叉B树，它有以下一些特点
	* 是二叉搜索树，即意味着它与上面的基本二叉搜索树有一致的基本特点，中序遍历就是排序
	* 节点有颜色区分，红色或者黑色
	* 根节点是黑色
	* 树的叶子节点有些为null（即还没有插入数据的叶子），是黑色的
	* 红色节点的两个子节点都是黑色的（每个叶子到根的所有路径上不能有两个连续的红色节点）
	* 根节点到叶子的所有路径都包含相同数目的黑色节点（这个数值称为黑高度）
### B树
+ 平衡树的意思（B树/B-树指的是同一种东西），学习理解B树之前，最好先认识一下2-3树
+ 2-3树是B树的一种特例，B树是一种平衡的多路查找树（即也具备查找树的一些特性）
+ B树的阶，树中节点最大的孩子数目称为它的阶，以下是m阶B树的一些性质（参照2-3树理解）
	* 数中每个节点有x个儿子（对应着x-1个关键字），x最大不超过m，儿子数量与关键字数量是确定的相互的关系
	* 若根节点不是叶子节点，那它最少有2个儿子（一个关键字）
	* ! 除根节点外,所有非叶子节点至少有【m/2】个儿子（【m/2】-1个关键字，【m/2】向上取整）
	* 非叶子节点的结构
		+ 儿子数量 = 关键字数量+1，关键字有严格大小关系，以此区分儿子节点
		+ 每两个关键字夹着一个儿子节点
	* ! 所有叶子节点都在同一层次上，而且是null节点（在统计B树高度的时候，有些书是不带叶子节点，有些带，就是这个原因，null节点在实际图上是不画出来的，也可以当它不存在）
	* B树的操作
		+ 建立B树（根据一系列关键字建立m阶B树）
		+ 插入
		+ 删除
			* 终端节点（即叶子节点的上一层，叶子节点是null，理解？）的删除
			* 非终端节点的删除（转换到终端节点进行删除）
+ B+树（有点难，这里不做解释，自行查阅资料了解）
### 2-3树
+ 一种多路查找树，他有以下一些特点
	* 它所有的结点都必须是2节点或者3节点
	* 2节点，指包含一个元素（或者称为关键字，用于比较查找），有2个儿子或者没有儿子的节点
		+ 不能只有一个儿子，要么2个要么没有（这也是2节点命名的原因）
		+ 左子树元素小于该元素
		+ 右子树元素大于该元素
	* 3节点，指包含两个元素（姑且称为大元素和小元素），有3个儿子或者没有儿子的节点
		+ 不能只有一个或两个儿子，要么3个要么没有（3节点命名的原因）
		+ 左子树元素小于小元素
		+ 中间子树元素大于小元素小于大元素
		+ 右子树元素大于大元素
	* 所有叶子节点都在同一个层次（即都在最底层）
+ 由上面可推出2-3-4树，多出的一个4节点，自行类推脑补，脑补不出来请放弃学习

