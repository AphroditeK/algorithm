### 该包主要讨论与堆以及堆排序相关的算法问题
#### 普通队列：先进先出，顺序与实时间有关的队列
#### 优先队列：出入顺序与时间无关，与优先级有关的队列
+ 一般来说现实生活中会较多使用优先队列，像医院排队，病情代表优先级，同级的使用普通队列。
+ 计算机进程，cpu只有一个，多进程的实现就是让cpu处理碎片化，进程交替使用cpu资源，由于处理器速度很快,
所以通常以人类的反应速度是感觉不到其中交替的过程，错觉地以为进程在同时进行，其实并不然。
进程调用硬件资源用的就是优先队列的实现方式，按照优先级给予优先调用资源的权利。
	* 优先队列能让多进程的用户体验更好
	* 计算机系统为进程赋予优先级的方式是动态的，也就是说优先级并不是进程一开始就固定的内容
	* 动态的优先级就使得优先队列不断地处于动态变化过程中 
	* 优先队列的实现（优先队列主要是入队与出队操作，出队需要按照优先级来出）
	
		|数据结构|入队|出队|
		|:--:|:--:|:--:|
		|普通数组|O(1)|O(n)|
		|顺序数组|O(n)|O(1)|
		|堆|O(lgn)|O(lgn)|
#### 堆
+ 一种数据结构,用于实现优先队列有明显优势
+ 常见的堆有二叉堆、斐波那契堆
	* 二叉堆（本质是一颗二叉树）
		+ 是一颗完全二叉树
		+ 每个节点总是不大于或不小于父节点（这里的大小关系是对整棵树统一的）
		+ 根据这个大小关系，根节点就会要么最大，要么最小，就 分为最大堆与最小堆
		+ 常见实现是用顺序存储结构（数组）实现,它有以下一些特点
			- 二叉树从上到下，从左到右依次存储
			- 从下标1开始存储数据有利于结点定位
			- 所有左子结点下标都是偶数，且是父节点的2倍
			- 所有右子节点下标都是奇数，且是父节点的(2倍+1)
			
### 索引堆
+ problem(1)-只维护index的索引堆如何实现堆data数据源的维护？
	* 出堆操作extractMax里面只维护了index，那如何删除data中的源数据?
	* 由于没有维护data，那么count--之后再进行insert操作就把data中最后一个数据给替换了怎么解决？
	* 按照原作者的做法在insert时传入i下标，那用户如何判断该下标是否已经存在值？
	* 不判断的话又怎样防止insert操作变成了replace？
	* 如果按照本人想法就是data不删除，但插入时就统统往后放，但是这样原本出堆的无用数据就还会卡在data里面，浪费了空间这又如何解决？
	* 或者把出堆的data还原为null，但是insert时又如何利用上这些为null的位置？