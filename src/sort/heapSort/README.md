### 该包主要讨论与堆以及堆排序相关的算法问题
#### 普通队列：先进先出，顺序与实时间有关的队列
#### 优先队列：出入顺序与时间无关，与优先级有关的队列
+ 一般来说现实生活中会较多使用优先队列，像医院排队，病情代表优先级，同级的使用普通队列。
+ 计算机进程，cpu只有一个，多进程的实现就是让cpu处理碎片化，进程交替使用cpu资源，由于处理器速度很快,
所以通常以人类的反应速度是感觉不到其中交替的过程，错觉地以为进程在同时进行，其实并不然。
进程调用硬件资源用的就是优先队列的实现方式，按照优先级给予优先调用资源的权利。
	* 优先队列能让多进程的用户体验更好
	* 计算机系统为进程赋予优先级的方式是动态的，也就是说优先级并不是进程一开始就固定的内容
	* 动态的优先级就使得优先队列不断地处于动态变化过程中 
	* 优先队列的实现（优先队列主要是入队与出队操作，出队需要按照优先级来出）
	
		|数据结构|入队|出队|
		|:--:|:--:|:--:|
		|普通数组|O(1)|O(n)|
		|顺序数组|O(n)|O(1)|
		|堆|O(lgn)|O(lgn)|
#### 堆
+ 一种数据结构,用于实现优先队列有明显优势
+ 常见的堆有二叉堆、斐波那契堆
	* 二叉堆（本质是一颗二叉树）
		+ 是一颗完全二叉树
		+ 每个节点总是不大于或不小于父节点（这里的大小关系是对整棵树统一的）
		+ 根据这个大小关系，根节点就会要么最大，要么最小，就 分为最大堆与最小堆
		+ 常见实现是用顺序存储结构（数组）实现,它有以下一些特点
			- 二叉树从上到下，从左到右依次存储
			- 从下标1开始存储数据有利于结点定位
			- 所有左子结点下标都是偶数，且是父节点的2倍
			- 所有右子节点下标都是奇数，且是父节点的(2倍+1)
			
### 索引堆
+ problem(1)-面向用户的内容究竟是什么？
	* 在索引堆中，用户插入数据时面向的是data，但是用户所有的操作都是面向堆的，那么实际要对用户屏蔽的对象究竟是什么，是data还是由整理index得到的堆结构？
	* 假设面向用户的就是由data整理得到的堆结构，但实际算法底层是利用index维护堆的，那么该怎样设计操作才是合理的？
+ problem(2)-只维护index的索引堆如何实现堆data数据源的维护？
	* 出堆操作extractMax里面只维护了index，那如何删除data中的源数据?
	* 由于没有维护data，那么count--之后再进行insert操作就把data中最后一个数据给替换了怎么解决？
	* 按照原作者的做法在insert时传入i下标，那用户如何判断该下标是否已经存在值？
	* 不判断的话又怎样防止insert操作变成了replace？
	* 如果按照本人想法就是data不删除，但插入时就统统往后放，但是这样原本出堆的无用数据就还会卡在data里面，浪费了空间这又如何解决？
	* 或者把出堆的data还原为null，但是insert时又如何利用上这些为null的位置？
+ 我的理解：
	* 自我理解的是：面向用户的其实是data数组，用户可以随意操作它，而算法中的堆结构只是一种手段，为了更快排序，找最大值等等这些堆结构优势的算法手段
	* 那么这样就说得通了，data是面向用户的数据，index是算法底层用来实现堆结构并且能够使用堆结构一系列的方便性能的内部结构，面向用户来说，用户是不知道了，用户知道的是他可以通过这个来修改插入data，修改data，删除data
	* 那么算法中所谓的出堆其实就是返回一个最大值给用户，这个过程出堆出的是index，而想要删除data只能是用户操作
	* 在insert中也有个问题就是新插入的data数据会自动入堆，但是已经出堆的数据(数据只是出了index，并没有从data中删除的)，就没有办法再重新进堆了，想要让数据重新进堆，就只能重新插入一个一模一样的数据
+ 与理解冲突得地方
	* 假设算法面向用户的是data，出现矛盾！因为算法中很多方法操作又都是面向堆的
	* getItem操作，原作者认为getItem要先判断item是否在堆中，不在的话事不允许get的，那这里就说明面向用户的是堆结构，而不是data数组结构
	* change操作也是，原作者也认为要先判断，在堆结构中的才能修改，不在的不允许修改
	
# 那么问题来了，面向用户使用的到底是data呢还是堆呢？
# 如果是堆那么怎么处理data呢？(出堆操作中并没有把真正的数据从data中删除)
# 如果是data数组那怎么解释change/get这些操作要面向堆呢？